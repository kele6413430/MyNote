2-1 线程安全性
1、当多个线程访问一个类时，如果不用考虑这些线程在运行时的调度和交替执行，并且不需要额外的同步及在调用方代码不必做其它的协调，这个类的行为仍然是正确的，那么这个类是线程安全的
2、对于线程安全的类的实例进行顺序或并发的一系列操作，都不会导致实例处于无效状态
3、线程安全的类封装了任何必要的同步，因此客户不需要自己提供



2-2 原子性
1、无状态对象永远是线程安全的
2、原子性 相对于同一状态下的其它操作而言，必须是原子性的或不可分割的。为了避免竞争条件，必须组织其它线程访问我们正在修改的变量，让我们可以确保：当其它线程想要查看或修改一个状态时，必须在我们的线程开始之前或之后，而不能在操作过程中。

1、java.util.concurrent.atomic包中包括了原子变量类(atomic variable)，这些类用来实现数字和对象引用的原子状态转换
2、引用像AtoMicLong已有的线程安全对象管理类的状态是非常实用的。相比于非线程安全对象，判断一个线程安全对象的可能状态和状态的转换要容易的多，这简化了维护和验证线程安全性的工作

2-3 锁
1、为了保护状态的一致性，要在单一的原子操作中更新相互关联的状态变量
  内部锁
2、Java提供了强制原子性的内置锁机制，synchronized块。
   一个synchronized块有两部分，锁对象的引用，以及这个锁保护的代码块。
   synchronized方法是跨越了整个方法体的synchronized块的简短描述。
   至于synchronized块的锁，就是该方法所在的对象本身，
   而静态的synchronized方法从Class对象上获取锁。
   每个Java对象都可以隐式地扮演一个用于同步的锁的角色；这些内置的锁被称作内部锁(intrinsic lock)或监视器锁(monitor locks)
   内部锁在Java中扮演了互斥锁(mutual exclusion lock)的角色
3、重进入Reentrancy
   当一个线程请求其他线程已经占有的锁时，请求线程将被阻塞。然而内部锁是可重进入的，因此线程在试图获取它已经占有的锁时，请求会成功。重进入意味着所有的请求是基于每个线程，而不是基于每次调用。重进入的实现是通过为每一个锁关联一个请求计数和一个占有它的线程。当计数为0时，认为锁是未被占用的。线程请求一个未被占有的锁时，JVM将记录锁的占有者，并且将请求计数置为1。如果同一线程在此请求这个锁时，计数将递增；每次占用线程退出同步块时，计数将递减，直至计数器达到0，锁被释放。

2-4 用锁来保护状态
1、对于每个可被多个线程访问的可变状态变量，如果所有访问它的线程在执行时都占有同一个锁，这种情况下，我们称这个变量是由这个锁保护    的。
2、一种常见的错误观念认为，只有写入共享变量时才需要同步，其实并非如此
3、每个共享的可变变量都需要由唯一一个确定的锁保护。而维护者应该清楚这个锁。
4、对于每一个涉及多个变量的不变约束，需要同一个锁保护其所有的变量
   如 if(!vector.contain(element)){
	vector.add(element);
   }
